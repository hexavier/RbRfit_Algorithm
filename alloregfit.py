# -*- coding: utf-8 -*-

#%% Import modules
import pandas as pd
import sympy as sym

#%% Define reactions
# For each of the reactions, the function creates a data frame where every row constitutes a reaction.
# Inputs: list of reaction ids that will be analyzed, stoichiometric model, DataFrame containing fluxes x conditions,
# DataFrame containing prot x cond, and DataFrame with metabolites x cond.

def define_reactions(rxn_id, model, fluxes, prot, metab):
    mapping = pd.read_table("ECOLI_83333_idmapping.dat",header=None)
    reaction, reactant, product, enzyme, flux = ([] for l in range(5))
    for i in range(len(rxn_id)):
        # Reaction value
        reaction.append(model.reactions.get_by_id(rxn_id[i]).reaction)
        # Reactant values
        react = model.reactions.get_by_id(rxn_id[i]).reactants
        react_df = []
        name_r = []
        for j in range(len(react)):
            met_r = react[j].id[:-2] #strip compartment letter from id
            if (any(met_r in s for s in ['h','h2o'])==0):
                react_df.append(metab.loc[met_r].values)
                name_r.append(react[j].id)
        react_df = pd.DataFrame(react_df,columns = metab.columns, index = name_r)
        reactant.append(react_df)
        # Product values
        prod = model.reactions.get_by_id(rxn_id[i]).products
        prod_df = []
        name_p = []
        for j in range(len(prod)):
            met_p = prod[j].id[:-2] #strip compartment letter from id
            if (any(met_p in s for s in [metab.index.values])&(any(met_p in s for s in ['h','h2o'])==0)):
                prod_df.append(metab.loc[met_p].values)
                name_p.append(prod[j].id)
        prod_df = pd.DataFrame(prod_df,columns = metab.columns, index = name_p)
        product.append(prod_df)
        # Enzyme values
        enz = list(model.reactions.get_by_id(rxn_id[i]).genes)
        enz_df = []
        name_e = []
        for j in range(len(enz)):
            gene = mapping[mapping[2]==enz[j].id][0].reset_index()
            gene = list(mapping[(mapping[0]==gene[0][0]) & (mapping[1]=='Gene_Name')][2])
            if any(gene[0] in s for s in [prot.index.values]):
                enz_df.append(prot.loc[gene[0]].values)
                name_e.append(gene)
        enz_df = pd.DataFrame(enz_df, columns = prot.columns, index = name_e)
        enzyme.append(enz_df)
        # Flux values
        flux.append(pd.DataFrame([fluxes.loc[rxn_id[i]].values],columns = fluxes.columns, index = [rxn_id[i]]))
        
    binding_site = [[['fum_c','mal_L_c']],[['6pgc_c'],['nadp_c','nadph_c']]\
                    ,[['mal_L_c'],['nad_c','nadh_c']],[['atp_c','adp_c'],['f6p_c','fdp_c']]\
                    ,[['g6p_c','f6p_c']],[['atp_c','amp_c'],['pyr_c','pep_c']]\
                    ,[['adp_c','atp_c'],['pep_c','pyr_c']],[['r5p_c']]]
    
    summary = pd.DataFrame({'idx':range(len(rxn_id)),'reaction':reaction,'rxn_id':rxn_id,\
                            'reactant':reactant,'product':product,\
                            'enzyme':enzyme,'flux':flux,'binding_site':binding_site})
    summary.set_index('idx')
    return summary

#%% Write Rate Equations
# For each of the models, write one rate equation expression. If products are available, include them.
# Inputs: summary generated by define_reactions, idx defining the reaction that is analyzed,
# stoichiometric model and candidates dataframe.

def write_rate_equations(idx,summary, model, candidates=None):
    if candidates is None:
        parameters, species, speciestype = ([] for i in range(3))
        # Define Vmax expression:
        enzyme = list(summary['enzyme'][idx].index)
        vmax = sym.sympify('0')
        for enz in enzyme:
            K = str('K_cat_%s' % enz)
            E = str('c_%s' % enz)
            vmax += sym.sympify(K+'*'+E)
            parameters.append(K), species.append(enz), speciestype.append('enz')
            
        # Define occupation term. Start with the numerator:
        reaction = model.reactions.get_by_id(summary['rxn_id'][idx])
        substrate = list(summary['reactant'][idx].index)
        num1 = sym.sympify('1')
        num2 = sym.sympify('1')
        for sub in substrate:
            K = str('K_%s' % sub)
            num1 *= sym.sympify(K)
            S = str('c_%s' % sub)
            exp = abs(reaction.get_coefficient(sub))
            num2 *= sym.sympify(S+'**'+str(exp))
            parameters.append(K), species.append(sub), speciestype.append('met')
        num1 = 1/num1            
        
        product = list(summary['product'][idx].index)
        if product:
            num3 = sym.sympify('1')
            for prod in product:
                P = str('c_%s' % prod)
                exp = abs(reaction.get_coefficient(prod))
                num3 *= sym.sympify(P+'**'+str(exp))
            K_eq = sym.symbols('K_eq')
            parameters.append('K_eq'), species.append('K_eq'), speciestype.append('K_eq')
            num3 = (1/K_eq)*num3
            num = num1*(num2-num3)
        else:
            num = num1*num2
        
        # Define the denominator:
        den = sym.sympify('1')
        for i,site in enumerate(summary['binding_site'][idx]):
            den_site = sym.sympify('1')
            for met in summary['binding_site'][idx][i]:
                exp = int(abs(reaction.get_coefficient(met)))
                for j in range(1, (exp+1)):
                    R = str('c_%s' % met)
                    K = str('K_%s' % met)
                    den_site += sym.sympify('('+R+'/'+K+')**'+str(j))
                    parameters.append(K), species.append(met), speciestype.append('met')
            den *= den_site
        
        # Paste all the parts together:
        expr = vmax*(num/den)
        
        # Generate list of parameters:
        parframe = pd.DataFrame({'parameters':parameters,'species':species,'speciestype':speciestype})
        parframe.drop_duplicates('parameters',inplace=True)
        parframe.reset_index(drop=True,inplace=True)
        
        return expr,parframe

#%% Build parameter priors
# For each of the parameters, define the prior/proposal distribution needed for MCMC.
# Inputs: dataframe with parameters, summary generated in define_reactions, the 
# stoichiometric model, and candidate dataframe.            
def build_priors(param, idx, summary, model, candidates=None):
    from numpy import log2,nanmedian,nan
    reaction = model.reactions.get_by_id(summary['rxn_id'][idx])
    distribution, par1, par2 = ([] for i in range(3))
    for i,par in enumerate(param['parameters']):
        if param['speciestype'][i] == 'met':
            distribution.append('unif')
            if any(param['species'][i] in s for s in [summary['reactant'][idx].index.values]):
                par1.append(-15.0+log2(nanmedian(summary['reactant'][idx].loc[param['species'][i]].values)))
                par2.append(15.0+log2(nanmedian(summary['reactant'][idx].loc[param['species'][i]].values)))
            elif any(param['species'][i] in s for s in [summary['product'][idx].index.values]):
                par1.append(-15.0+log2(nanmedian(summary['product'][idx].loc[param['species'][i]].values)))
                par2.append(15.0+log2(nanmedian(summary['product'][idx].loc[param['species'][i]].values)))
        elif param['speciestype'][i] == 'enz':
            distribution.append(nan)
            par1.append(nan)
            par2.append(nan)
        elif param['speciestype'][i] == 'K_eq':
            distribution.append('unif')
            Q_r = 1
            for subs in list(summary['reactant'][idx].index):
                Q_r /= (summary['reactant'][idx].loc[subs].values)**abs(reaction.get_coefficient(subs))
            products = list(summary['product'][idx].index.values)
            if products:
                for prod in products:
                    Q_r *= (summary['product'][idx].loc[prod].values)**abs(reaction.get_coefficient(prod))
                par1.append(-20.0+log2(nanmedian(Q_r)))
                par2.append(20.0+log2(nanmedian(Q_r)))
    param['distribution'] = pd.Series(distribution, index=param.index)
    param['par1'] = pd.Series(par1, index=param.index)
    param['par2'] = pd.Series(par2, index=param.index)
    return param
